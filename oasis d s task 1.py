# -*- coding: utf-8 -*-
"""Iris_classification_decision tree

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/iris-classification-decision-tree-5645fca9-71b3-414e-8371-f5dc2f616901.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20240807/auto/storage/goog4_request%26X-Goog-Date%3D20240807T061308Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D853851b28f24722b17b5b591a8f2fc212e9fbdf8b50d354561b408329731078303fe78368aa96f8a79b1f3b846a531563ea92c6010d350b66f95172ad8d8af4d8fb77b1e05d5e8d0db0d84da4bb606649475374edc1bca8f2cfb95edc9c791ad549553eedfc5b4b94f150830d304079fe2ef98f77b88e8aafd4803361ac94f876b79b9e18bd56c5979a6ca9935a0629b89e316e2b203cf1a732c4306fa22a98f5293ffb12a06ff3b3ee7445117b8414ac507532701ad15cb8ae47d4f7f3f365d2d9c965f3fbadd0f579e6764ed6c3d65b5efd801654b2ee0b376358d40f8bd16801a6436cdf13ae9d83de1984d48c45d567b17a6aabd21b4196ff3f1a33543ad
"""

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES
# TO THE CORRECT LOCATION (/kaggle/input) IN YOUR NOTEBOOK,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.

import os
import sys
from tempfile import NamedTemporaryFile
from urllib.request import urlopen
from urllib.parse import unquote, urlparse
from urllib.error import HTTPError
from zipfile import ZipFile
import tarfile
import shutil

CHUNK_SIZE = 40960
DATA_SOURCE_MAPPING = 'iris-flower-dataset:https%3A%2F%2Fstorage.googleapis.com%2Fkaggle-data-sets%2F17860%2F23404%2Fbundle%2Farchive.zip%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com%252F20240807%252Fauto%252Fstorage%252Fgoog4_request%26X-Goog-Date%3D20240807T061308Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D6b6dd09a1ae0300eab220cabebaf2ce29ec26666c5aa8abfddf00ccf61d8afd369ff7d7461155581e0c491e29bc19790020eed2883d192818fbea1d7a64edd08a84c4a6ff1d48bd1bfc59eda0614c859e0e1a6488fc33168a04a58680ab3f99a879c0ac5a49e4feaa8e11e74e42be20ef0aa47ea65eb808d6ea36e039cf229454d8fbeaca70c2a7fc0f13fd379fc5c789b481168c228d7f8a55d6fa80877a5a5a5fef00a45c0c2e3a9013a16cb6da3e691e9b189102ecd5bb004ca482808b0f05c32c5ab1d34f8b8c7882d2417f8befb2ee6fcf3278d2e7fac4564d588455f3e595a70a33b06f6c2b06a30a736827afa2d27da5cd6d9f03975209390af402c2b'

KAGGLE_INPUT_PATH='/kaggle/input'
KAGGLE_WORKING_PATH='/kaggle/working'
KAGGLE_SYMLINK='kaggle'

!umount /kaggle/input/ 2> /dev/null
shutil.rmtree('/kaggle/input', ignore_errors=True)
os.makedirs(KAGGLE_INPUT_PATH, 0o777, exist_ok=True)
os.makedirs(KAGGLE_WORKING_PATH, 0o777, exist_ok=True)

try:
  os.symlink(KAGGLE_INPUT_PATH, os.path.join("..", 'input'), target_is_directory=True)
except FileExistsError:
  pass
try:
  os.symlink(KAGGLE_WORKING_PATH, os.path.join("..", 'working'), target_is_directory=True)
except FileExistsError:
  pass

for data_source_mapping in DATA_SOURCE_MAPPING.split(','):
    directory, download_url_encoded = data_source_mapping.split(':')
    download_url = unquote(download_url_encoded)
    filename = urlparse(download_url).path
    destination_path = os.path.join(KAGGLE_INPUT_PATH, directory)
    try:
        with urlopen(download_url) as fileres, NamedTemporaryFile() as tfile:
            total_length = fileres.headers['content-length']
            print(f'Downloading {directory}, {total_length} bytes compressed')
            dl = 0
            data = fileres.read(CHUNK_SIZE)
            while len(data) > 0:
                dl += len(data)
                tfile.write(data)
                done = int(50 * dl / int(total_length))
                sys.stdout.write(f"\r[{'=' * done}{' ' * (50-done)}] {dl} bytes downloaded")
                sys.stdout.flush()
                data = fileres.read(CHUNK_SIZE)
            if filename.endswith('.zip'):
              with ZipFile(tfile) as zfile:
                zfile.extractall(destination_path)
            else:
              with tarfile.open(tfile.name) as tarfile:
                tarfile.extractall(destination_path)
            print(f'\nDownloaded and uncompressed: {directory}')
    except HTTPError as e:
        print(f'Failed to load (likely expired) {download_url} to path {destination_path}')
        continue
    except OSError as e:
        print(f'Failed to load {download_url} to path {destination_path}')
        continue

print('Data source import complete.')

"""## import needed libraries"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler , LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import confusion_matrix , classification_report ,accuracy_score

"""## EDA

### Read Data
"""

df=pd.read_csv('/kaggle/input/iris-flower-dataset/IRIS.csv')
df

df.head()

df.info()

df.describe()

df.describe(include='object')

df.isna().sum()

"""## visulization"""

count_iris=df['species'].value_counts()
count_iris

plt.figure(figsize = (20, 10))
explode = (0,0,0.09)
count_iris.plot(kind = 'pie', fontsize = 12, explode = explode, autopct = '%.1f%%')
plt.title('species')
plt.xlabel('species', weight = "bold", color = "#000000", fontsize = 14, labelpad = 20)
plt.ylabel('counts', weight = "bold", color = "#000000", fontsize = 14, labelpad = 20)
plt.legend(labels = count_iris.index, loc = "best")
plt.show()

df['sepal_length'].hist(figsize = (12,8))

df['sepal_width'].hist(figsize = (12,8))

df['petal_length'].hist(figsize = (12,8))

df['petal_width'].hist(figsize = (12,8))

plt.figure(figsize=(12,8))
ax=sns.barplot(x=df['species'],y=df['sepal_length'],palette='viridis')
ax.bar_label(ax.containers[0], fontsize=10);
plt.title('sepallenght by species')
plt.xlabel('species')
plt.ylabel('sepal_lenght')
plt.show()

plt.figure(figsize=(12,8))
ax=sns.barplot(x=df['species'],y=df['sepal_width'],palette='viridis')
ax.bar_label(ax.containers[0], fontsize=10);
plt.title('sepal_width by species')
plt.xlabel('species')
plt.ylabel('sepal_width')
plt.show()

plt.figure(figsize=(12,8))
ax=sns.barplot(x=df['species'],y=df['petal_length'],palette='viridis')
ax.bar_label(ax.containers[0], fontsize=10);
plt.title('petal_length by species')
plt.xlabel('species')
plt.ylabel('petal_length')
plt.show()

plt.figure(figsize=(12,8))
ax=sns.barplot(x=df['species'],y=df['petal_width'],palette='viridis')
ax.bar_label(ax.containers[0], fontsize=10);
plt.title('petal_width by species')
plt.xlabel('species')
plt.ylabel('petal_width')
plt.show()

"""## encoding data"""

le=LabelEncoder()
df['species']=le.fit_transform(df['species'])

df

"""## correlation data"""

plt.figure(figsize=(22, 18))
sns.heatmap(df.corr(), annot=True, fmt=".2f", linewidths=0.5, cbar=True)
plt.show()

"""## define features and target"""

x=df.drop(columns=['species'])
y=df['species']

y=y.values.reshape(-1,1)

y

"""## scaling data"""

scaler=MinMaxScaler()
x=scaler.fit_transform(x)

"""## split data"""

X_train,X_test,y_train,y_test=train_test_split(x,y,test_size=0.2,shuffle=True,random_state=42)

"""## Decision tree model"""

Dt=DecisionTreeClassifier()
Dt.fit(X_train,y_train)

Dt.score(X_train,y_train)

y_pred=Dt.predict(X_test)

print(accuracy_score(y_test,y_pred))

from sklearn.metrics import ConfusionMatrixDisplay
ConfusionMatrixDisplay.from_predictions(y_test, y_pred)
print(confusion_matrix(y_test, y_pred))

print(classification_report(y_test, y_pred))